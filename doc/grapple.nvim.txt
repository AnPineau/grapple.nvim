*grapple.nvim.txt*        For NVIM v0.8.0        Last change: 2022 November 27

==============================================================================
Table of Contents                             *grapple.nvim-table-of-contents*

1. Grapple.nvim                                    |grapple.nvim-grapple.nvim|
  - Introduction                                   |grapple.nvim-introduction|
  - Features                                           |grapple.nvim-features|
  - Requirements                                   |grapple.nvim-requirements|
  - Installation                                   |grapple.nvim-installation|
  - Default Settings                           |grapple.nvim-default-settings|
  - File Tags                                         |grapple.nvim-file-tags|
  - Popup Menu                                       |grapple.nvim-popup-menu|
  - Persistent Tag State                   |grapple.nvim-persistent-tag-state|
  - Suggested Keymaps                         |grapple.nvim-suggested-keymaps|
  - Integrations                                   |grapple.nvim-integrations|
  - Grapple Types                                 |grapple.nvim-grapple-types|
  - Inspiration and Thanks               |grapple.nvim-inspiration-and-thanks|

==============================================================================
1. Grapple.nvim                                    *grapple.nvim-grapple.nvim*


https://user-images.githubusercontent.com/2467016/204135078-c1c59f19-49b8-4c38-a76d-2892903816db.mov

_Theme: catppuccin <https://github.com/catppuccin/nvim>_

INTRODUCTION                                       *grapple.nvim-introduction*

Grapple is a plugin that aims to provide immediate navigation to important
files (and its last known cursor location) by means of persistent
|grapple.nvim-file-tags| within a |grapple.nvim-project-scope|. Tagged files
can be bound to a |grapple.nvim-keymap| or selected from within an editable
|grapple.nvim-popup-menu|.

To get started, |grapple.nvim-install| the plugin using your preferred package
manager and give it a go! Default settings for the plugin can be found in the
|grapple.nvim-settings| section below. The API provided by Grapple can be found
in the |grapple.nvim-usage| section below.

FEATURES                                               *grapple.nvim-features*


- **Project scoped** file tagging for immediate navigation
- **Persistent** cursor tracking for tagged files
- **Popup** menu to manage tags and scopes as regular text
- **Integration** with portal.nvim <https://github.com/cbochs/portal.nvim> for additional jump options


REQUIREMENTS                                       *grapple.nvim-requirements*


- Neovim >= 0.5 <https://github.com/neovim/neovim/releases/tag/v0.5.0>
- Neovim >= 0.9 - optional, for floating window title <https://github.com/neovim/neovim/issues/17458>
- plenary.nvim <https://github.com/nvim-lua/plenary.nvim>


INSTALLATION                                       *grapple.nvim-installation*

PACKER <HTTPS://GITHUB.COM/WBTHOMASON/PACKER.NVIM> ~

>
    use {
        "cbochs/grapple.nvim",
        requires = { "nvim-lua/plenary.nvim" },
    }
<


VIM-PLUG <HTTPS://GITHUB.COM/JUNEGUNN/VIM-PLUG> ~

>
    Plug "cbochs/grapple.nvim"
<


DEFAULT SETTINGS                               *grapple.nvim-default-settings*

The following are the default settings for Grapple. **Setup is not required**,
but settings may be overridden by passing them as table arguments to the
`grapplesetup` function.

>
    require("grapple").setup({
        ---@type "debug" | "info" | "warn" | "error"
        log_level = "warn",
    
        ---The scope used when creating, selecting, and deleting tags
        ---@type Grapple.ScopeKey | Grapple.ScopeResolver
        scope = "git",
    
        ---The save location for tags
        save_path = tostring(Path:new(vim.fn.stdpath("data")) / "grapple"),
    
        ---Window options used for the popup menu
        popup_options = {
            relative = "editor",
            width = 60,
            height = 12,
            style = "minimal",
            focusable = false,
            border = "single",
        },
    
        integrations = {
            ---Support for saving tag state using resession.nvim
            resession = false,
        },
    })
<


FILE TAGS                                             *grapple.nvim-file-tags*

A **tag** is a persistent tag on a file or buffer. It is a means of indicating
a file you want to return to. When a file is tagged, Grapple will save your
cursor location so that when you jump back, your cursor is placed right where
you left off. In a sense, tags are like file-level marks (`:h mark`).

There are a couple types of tag types available, each with a different use-case
in mind. The options available are |grapple.nvim-anonymous| and
|grapple.nvim-named| tags. In addition, tags are |grapple.nvim-scoped| to
prevent tags in one project polluting the namespace of another. For command and
API information, please see the |grapple.nvim-usage| below.

ANONYMOUS TAGS ~

This is the _default_ tag type. Anonymous tags are added to a list, where they
may be selected by index, cycled through, or jumped to using the
|grapple.nvim-tag-popup-menu| or plugins such as portal.nvim
<https://github.com/cbochs/portal.nvim>.

Anonymous tags are similar to those found in plugins like harpoon
<https://github.com/ThePrimeagen/harpoon>.

NAMED TAGS ~

Tags that are given a name are considered to be **named tags**. These tags will
not be cycled through with `cycle_{backward, forward}`, but instead must be
explicitly selected.

Named tags are useful if you want one or two keymaps to be used for tagging and
selecting. For example, the pairs `<leader>j/J` and `<leader>k/K` to
`select/toggle` a file tag (see: |grapple.nvim-suggested-keymaps|).

TAG SCOPES ~

A **scope** is a means of namespacing tags to a specific project. During
runtime, scopes are typically resolved into an absolute directory path
(i.e. current working directory), which - in turn - is used as the "root"
location for a set of tags.

Scope paths are _cached by default_, and will only update when triggered by a
provided autocommand event (|`:h autocmd`|). For example, the `static` scope
never updates once cached; the `directory` scope only updates on `DirChanged`;
and the `lsp` scope updates on either `LspAttach` or `LspDetach`.

A **scope path** is determined by means of a **|grapple.nvim-scope-resolver|**.
The builtin options are as follows:


- `none`: Tags are ephemeral and deleted on exit
- `global`: Tags are scoped to a global namespace
- `static`: Tags are scoped to neovim’s initial working directory
- `directory`: Tags are scoped to the current working directory
- `git`: Tags are scoped to the current git repository. **Fallback**: `static`
- `lsp`: Tags are scoped using the `root_dir` of the current buffer’s attached LSP server. **Fallback**: `static`


There are two additional scope resolvers which should be preferred when
creating a **|grapple.nvim-fallback-scope-resolver|**. These resolvers act
identically to their similarly named counterparts, but do not have default
fallbacks.


- `git_fallback`: The same as `git`, but without a fallback
- `lsp_fallback`: The same as `lsp`, but without a fallback


**Examples**

>
    -- Setup using a scope resolver's name
    require("grapple").setup({
        scope = "static"
    })
    
    -- Or, using the scope resolver itself
    require("grapple").setup({
        scope = require("grapple.scope").resolvers.static
    })
    
    -- Or, a custom scope resolver
    require("grapple").setup({
        scope = require("grapple.scope").resolver(function()
            return vim.fn.getcwd()
        end, { cache = "DirChanged" })
    })
<


For usage and examples, please see |grapple.nvim-scope-usage| and the Wiki
<https://github.com/cbochs/grapple.nvim/wiki/Tag-Scopes>, respectively.

USAGE ~

<details open>

Usage

                                                   *grapple.nvim-`grappletag`*

`grappletag`                           Create a scoped tag on a file or buffer
                                       with an (optional) tag key.


**Command**: `:GrappleTag [key={index} or key={name}] [buffer={buffer}]
[file_path={file_path}]`

**API**: `require("grapple").tag(opts)`

**`opts?`**: |grapple.nvim-`grapple.options`|


- **`buffer?`**: `integer` (default: `0`)
- **`file_path?`**: `string` (overrides `buffer`)
- **`key?`**: |grapple.nvim-`grapple.tagkey`|


**Note**: only one tag can be created _per scope per file_. If a tag already
exists for the given file or buffer, it will be overridden with the new tag.

**Examples**

>
    -- Tag the current buffer
    require("grapple").tag()
    
    -- Tag a file using its file path
    require("grapple").tag({ file_path = "{file_path}" })
    
    -- Tag the curent buffer using a specified key
    require("grapple").tag({ key = 1 })
    require("grapple").tag({ key = "{name}" })
<


                                                 *grapple.nvim-`grappleuntag`*

`grappleuntag`                         Remove a scoped tag on a file or buffer.


**Command**: `:GrappleUntag [key={name} or key={index}] [buffer={buffer}]
[file_path={file_path}]`

**API**: `require("grapple").untag(opts)`

**`opts`**: |grapple.nvim-`grapple.options`| (one of)


- **`buffer?`**: `integer` (default: `0`)
- **`file_path?`**: `string` (overrides `buffer`)
- **`key?`**: |grapple.nvim-`grapple.tagkey`| (overrides `buffer` and `file_path`)


**Examples**

>
    -- Untag the current buffer
    require("grapple").untag()
    
    -- Untag a file using its file path
    require("grapple").untag({ file_path = "{file_path}" })
    
    -- Untag a file using its tag key
    require("grapple").untag({ key = 1 })
    require("grapple").untag({ key = "{name}" })
<


                                                *grapple.nvim-`grappletoggle`*

`grappletoggle`                        Toggle a tag or untag on a file or
                                       buffer.


**Command**: `:GrappleToggle [key={index} or key={name}] [buffer={buffer}]
[file_path={file_path}]`

**API**: `require("grapple").toggle(opts)`

**`opts`**: |grapple.nvim-`grapple.options`|


- **`buffer?`**: `integer` (default: `0`)
- **`file_path?`**: `string` (overrides `buffer`)
- **`key?`**: |grapple.nvim-`grapple.tagkey`| (behaviour inherited from |grapple.nvim-grappletag| and |grapple.nvim-grappleuntag|)


**Examples**

>
    -- Toggle a tag on the current buffer
    require("grapple").toggle()
<


                                                *grapple.nvim-`grappleselect`*

`grappleselect`                        Select and open a tagged file or buffer
                                       in the current window.


**Command**: `:GrappleSelect [key={index} or key={name}]`

**API**: `require("grapple").select(opts)`

**`opts`**: |grapple.nvim-`grapple.options`| (one of)


- **`buffer?`**: `integer`
- **`file_path?`**: `string`
- **`key?`**: |grapple.nvim-`grapple.tagkey`| (preferred)


**Examples**

>
    -- Select an anonymous (numbered) tag
    require("grapple").select({ key = 1 })
    
    -- Select a named tag
    require("grapple").select({ key = "{name}" })
<


                                                  *grapple.nvim-`grapplefind`*

`grapplefind`                          Attempt to find a scoped tag.


**API**: `require("grapple").find(opts)`

**`returns`**: |grapple.nvim-`grapple.tag`| | `nil`

**`opts?`**: |grapple.nvim-`grapple.options`| (one of)


- **`buffer?`**: `integer` (default: `0`)
- **`file_path?`**: `string` (overrides `buffer`)
- **`key?`**: |grapple.nvim-`grapple.tagkey`| (overrides `buffer` and `file_path`)


**Examples**

>
    -- Find the tag associated with the current buffer
    require("grapple").find()
<


                                                   *grapple.nvim-`grapplekey`*

`grapplekey`                           Attempt to find the key associated with
                                       a file tag.


**API**: `require("grapple").key(opts)`

**`returns`**: |grapple.nvim-`grapple.tagkey`| | `nil`

**`opts?`**: |grapple.nvim-`grapple.options`| (one of)


- **`buffer?`**: `integer` (default: `0`)
- **`file_path?`**: `string` (overrides `buffer`)
- **`key?`**: |grapple.nvim-`grapple.tagkey`| (overrides `buffer` and `file_path`)


**Examples**

>
    -- Find the tag key associated with the current buffer
    require("grapple").key()
<


                                                *grapple.nvim-`grappleexists`*

`grappleexists`                        **API**:
                                       `require("grapple").exists(opts)`


**`returns`**: `boolean`

**`opts?`**: |grapple.nvim-`grapple.options`| (one of)


- **`buffer?`**: `integer` (default: `0`)
- **`file_path?`**: `string` (overrides `buffer`)
- **`key?`**: |grapple.nvim-`grapple.tagkey`| (overrides `buffer` and `file_path`)


**Examples**

>
    -- Check whether the current buffer is tagged or not
    require("grapple").exists()
<


                                                 *grapple.nvim-`grapplecycle`*

`grapplecycle`                         Cycle through and select from the
                                       available tagged files in a scoped tag
                                       list.


**Command**: `:GrappleCycle {direction}`

**API**:


- `require("grapple").cycle(direction)`
- `require("grapple").cycle_backward()`
- `require("grapple").cycle_forward()`


**`direction`**: `"backward"` | `"forward"`

**Note**: only |grapple.nvim-anonymous-tags| are cycled through, not
|grapple.nvim-named-tags|.

**Examples**

>
    -- Cycle to the previous tagged file
    require("grapple").cycle_backward()
    
    -- Cycle to the next tagged file
    require("grapple").cycle_forward()
<


                                                 *grapple.nvim-`grapplereset`*

`grapplereset`                         Clear all tags for a given tag scope.


**Command**: `:GrappleReset [scope]`

**API**: `require("grapple").reset(scope)`

**`scope?`**: |grapple.nvim-`grapple.scope`| (default: `settings.scope`)

**Examples**

>
    -- Reset tags for the current scope
    require("grapple").reset()
    
    -- Reset tags for a specified scope
    require("grapple").reset("global")
<


SCOPE USAGE ~

<details open>

Scope Usage

                                        *grapple.nvim-`grapple.scoperesolver`*

`grapple.scoperesolver`                Create a scope resolver that generates a
                                       scope path.


**API**: `require("grapple.scope").resolver(scope_function, opts)`

**`returns`**: |grapple.nvim-`grapple.scoperesolver`|

**`scope_function`**: |grapple.nvim-`grapple.scopefunction`|

**`opts?`**: |grapple.nvim-`grapple.scopeoptions`|


- **`key?`**: `string`
- **`cache?`**: `boolean` | `string` | `string[]` (default: `true`)


**Example**

>
    -- Create a scope resolver that updates when the current working
    -- directory changes
    require("grapple.scope").resolver(function()
        return vim.fn.getcwd()
    end, { cache = "DirChanged" })
<


                                            *grapple.nvim-`grapple.scoperoot`*

`grapple.scoperoot`                    Create a scope resolver that generates a
                                       scope path by looking upwards for
                                       directories containing a specific file
                                       or directory.


**API**: `require("grapple.scope").root(root_names, opts)`

**`returns`**: |grapple.nvim-`grapple.scoperesolver`|

**`root_names`**: `string` | `string[]`

**`opts?`**: |grapple.nvim-`grapple.scopeoptions`|


- **`key?`**: `string`
- **`cache?`**: `boolean` | `string` | `string[]` (default: `"DirChanged"`)


**Note**: it is recommended to use this with a
**|grapple.nvim-fallback-scope-resolver|** to guarantee that a scope is found.

**Example**

>
    -- Create a root scope resolver that looks for a directory containing
    -- a ".git" folder
    require("grapple.scope").root(".git")
    
    -- Create a root scope resolver that falls back to using the initial working
    -- directory for your neovim session
    require("grapple.scope").fallback({
        require("grapple.scope").root(".git"),
        require("grapple.scope").resolvers.static,
    })
<


                                        *grapple.nvim-`grapple.scopefallback`*

`grapple.scopefallback`                Create a scope resolver that generates a
                                       scope path by attempting to get the
                                       scope path of other scope resolvers, in
                                       order.


**API**: `require("grapple.scope").fallback(scope_resolvers, opts)`

**`returns`**: |grapple.nvim-`grapple.scoperesolver`|

**`scope_resolvers`**: |grapple.nvim-`grapple.scoperesolver[]`|

**`opts?`**: |grapple.nvim-`grapple.scopeoptions[]`|


- **`key?`**: `string`
- **`cache?`**: `boolean` | `string` | `string[]` (default: `false`)


**Example**

>
    -- Create a fallback scope resolver that first tries to use the LSP for a scope
    -- path, then looks for a ".git" repository, and finally falls back on using
    -- the initial working directory that neovim was started in
    require("grapple.scope").fallback({
        require("grapple.scope").resolvers.lsp_fallback,
        require("grapple.scope").resolvers.git_fallback,
        require("grapple.scope").resolvers.static
    }, { key = "my_fallback" })
<


                                      *grapple.nvim-`grapple.scopeinvalidate`*

`grapple.scopeinvalidate`              Clear the cached scope path, forcing the
                                       next call to `grapple.scopeget` to
                                       resolve the scope path instead of using
                                       its previously cached value.


**API**: `require("grapple.scope").invalidate(scooe_resolver)`

**`scope_resolver`**: |grapple.nvim-`grapple.scopekey`| |
|grapple.nvim-`grapple.scoperesolver`|

**Example**

>
    require("grapple.scope").resolver(function()
        return vim.fn.getcwd()
    end, { key = "my resolver" })
    
    -- Invalidate a cached scope by its key name
    require("grapple.scope").invalidate("my resolver")
<


POPUP MENU                                           *grapple.nvim-popup-menu*

A popup menu is available to enable easy management of tags and scopes. The
opened buffer (filetype: `grapple`) can be modified like a regular buffer;
meaning items can be selected, modified, reordered, or deleted with well-known
vim motions. Currently, there are two available popup menus: one for
|grapple.nvim-tags| and another for |grapple.nvim-scopes|.

<img width="1073" alt="Screenshot 2022-11-27 at 05 59 52"
src="https://user-images.githubusercontent.com/2467016/204136568-85100000-81fa-412e-8ca0-26df538cccee.png">

TAG POPUP MENU ~

The **tags popup menu** opens a floating window containing all the tags within
a specified scope. The floating window can be exited with either `q`, `<esc>`,
or any keybinding that is bound to `<esc>`. Several actions are available
within the tags popup menu: **Selection**: a tag can be selected by moving to
its corresponding line and pressing enter (`<cr>`) **Deletion**: a tag (or
tags) can be removed by deleting them from the popup menu (i.e. NORMAL `dd`
and VISUAL `d`) **Reordering**: an |grapple.nvim-anonymous-tag| (or tags) can
be reordered by moving them up or down within the popup menu. Ordering is
determined by the tags position within the popup menu: top (first index) to
bottom (last index) **Renaming**: a |grapple.nvim-named-tag| can be renamed by
editing its key value between the `[` square brackets `]`

**Command**: `:GrapplePopup tags`

**API**: `require("grapple").popup_tags(scope)`

**`scope?`**: |grapple.nvim-`grapple.scope`| (default: `settings.scope`)

**Examples**

>
    -- Open the tags popup menu in the current scope
    require("grapple").popup_tags()
    
    -- Open the tags popup menu in a different scope
    require("grapple").popup_tags("global")
<


SCOPE POPUP MENU ~

The **scopes popup menu** opens a floating window containing all the scope
paths that have been created. A scope (or scopes) can be deleted with typical
vim edits (i.e. NORMAL `dd` and VISUAL `d`). The floating window can be exited
with either `q` or any keybinding that is bound to `<esc>`. The total number of
tags within a scope will be displayed to the left of the scope path.

**Command**: `:GrapplePopup scopes`

**API**: `require("grapple.popup_scopes()`

**Examples**

>
    -- Open the scopes popup menu
    require("grapple").popup_scopes()
<


PERSISTENT TAG STATE                       *grapple.nvim-persistent-tag-state*

Grapple saves all |grapple.nvim-tag-scopes| to a common location, specified in
the |grapple.nvim-settings|. Each non-empty tag scope (contains at least one
tagged file) will be saved as its individiual scope file, serialized as a JSON
blob, and named using the resolved tag scope’s path. Each tag in a tag scope
will contain two pieces of information: the absolute `file path` of the tagged
file and its last known `cursor` location.

When a user loads Grapple, no tags are loaded initially. Instead, Grapple will
wait until the user requests a tag scope (e.g. |grapple.nvim-tagging-a-file|
or opening the |grapple.nvim-tags-popup-menu|). At that point, one of three
things can occur: the tag scope is **already loaded**, nothing is needed to be
done the tag scope has **not been loaded**, attempt to load tag scope from its
associated scope file the tag scope file was **not found**, initialize the tag
scope as an empty table

SUGGESTED KEYMAPS                             *grapple.nvim-suggested-keymaps*

                                          *grapple.nvim-Anonymous-tag-keymaps*

>
    vim.keymap.set("n", "<leader>m", require("grapple").toggle, {})
<


                                              *grapple.nvim-Named-tag-keymaps*

>
    vim.keymap.set("n", "<leader>j", function()
        require("grapple").select({ key = "{name}" })
    end, {})
    
    vim.keymap.set("n", "<leader>J", function()
        require("grapple").toggle({ key = "{name}" })
    end, {})
<


INTEGRATIONS                                       *grapple.nvim-integrations*

STATUSLINE ~

A statusline component can be easily added to show whether a buffer is tagged
or not by using either (or both) |grapple.nvim-`grapplekey`| and
|grapple.nvim-`grapplefind`|.

**Simple lualine.nvim <https://github.com/nvim-lualine/lualine.nvim>
statusline**

>
    require("lualine").setup({
        sections = {
            lualine_b = {
                {
                    require("grapple").key,
                    cond = require("grapple").exists
                }
            }
        }
    })
<


RESESSION.NVIM <HTTPS://GITHUB.COM/STEVEARC/RESESSION.NVIM> ~

Support is available to use resession.nvim
<https://github.com/stevearc/resession.nvim> for persisting tag state.

**Usage**

>
    -- Enable resession integration during grapple setup
    require("grapple").setup({
        integrations = {
            resession = true
        }
    })
    
    -- Enable grapple extension during resession setup
    require("resession").setup({
        extensions = {
            grapple = {}
        }
    })
<


GRAPPLE TYPES                                     *grapple.nvim-grapple-types*

<details open>

Type Definitions

`GRAPPLE.OPTIONS` ~

Options available for most top-level tagging actions (e.g. tag, untag, select,
toggle, etc).

**Type**: `table`


- **`buffer`**: `integer`
- **`file_path`**: `string`
- **`key`**: |grapple.nvim-`grapple.tagkey`|


------------------------------------------------------------------------------

`GRAPPLE.TAG` ~

A tag contains two pieces of information: the absolute `file_path` of the
tagged file, and the last known `cursor` location. A tag is stored in a tag
table keyed with a |grapple.nvim-`grapple.tagkey`|, but can only be
deterministically identified by its `file_path`.

**Type**: `table`


- **`file_path`**: `string`
- **`cursor`**: `integer[2]` (row, column)


------------------------------------------------------------------------------

`GRAPPLE.TAGKEY` ~

A tag may be referenced as an |grapple.nvim-anonymous-tag| by its index
(`integer`) or a |grapple.nvim-named-tag| by its key (`string`).

**Type**: `integer` | `string`

------------------------------------------------------------------------------

`GRAPPLE.SCOPEOPTIONS` ~

Options available when creating custom scope resolvers. Giving a scope resolver
a `key` will allow it to be identified within the
`require("grapple.scope").resolvers` table. In addition, a scope may also be
cached. The `cache` option may be one of the following: `cache = true`: scope
path is resolved once and cached until explicitly invalidated `cache = false`
scope path is never cached and must always be resolved `cache = string |
string[]` scope path is cached and invalidated when a given autocommand event
is triggered (see: |`:h autocmd`|)

**Type**: `table`


- **`key`**: `string`
- **`cache`**: `boolean` | `string` | `string[]`


------------------------------------------------------------------------------

`GRAPPLE.SCOPEKEY` ~

A **|grapple.nvim-scope-resolver|** is identified by its **scope key** in the
`require("grapple.scope").resolvers` table. When not explicitly set in
|grapple.nvim-`grapple.scopeoptions`|, a scope resolver will be appended to the
end of the `resolvers` table and the resolver’s key will be given that index.

**Type**: `string` | `integer`

------------------------------------------------------------------------------

`GRAPPLE.SCOPEPATH` ~

**Type**: `string`

------------------------------------------------------------------------------

`GRAPPLE.SCOPEFUNCTION` ~

**Type**: `fun(): Grapple.ScopePath | nil`

------------------------------------------------------------------------------

`GRAPPLE.SCOPERESOLVER` ~

**Type**: `table`


- **`key`**: |grapple.nvim-`grapple.scopekey`|
- **`resolve`**: |grapple.nvim-`grapple.scopefunction`|
- **`cache`**: `boolean` | `string` | `string[]`
- **`autocmd`**: `number` | `nil`


------------------------------------------------------------------------------

`GRAPPLE.SCOPE` ~

A scope determines how tags are separated for a given project.

**Type**: |grapple.nvim-`grapple.scopekey`| |
|grapple.nvim-`grapple.scoperesolver`|

INSPIRATION AND THANKS                   *grapple.nvim-inspiration-and-thanks*


- tjdevries vlog.nvim <https://github.com/tjdevries/vlog.nvim>
- ThePrimeagen’s harpoon <https://github.com/ThePrimeagen/harpoon>
- kwarlwang’s bufjump.nvim <https://github.com/kwkarlwang/bufjump.nvim>


Generated by panvimdoc <https://github.com/kdheepak/panvimdoc>

vim:tw=78:ts=8:noet:ft=help:norl:
